/**
 * Generated by @openapi-codegen
 *
 * @version 0.0.1
 */
import * as reactQuery from "@tanstack/react-query";
import { useServerContext, ServerContext } from "./serverContext";
import type * as Fetcher from "./serverFetcher";
import { serverFetch } from "./serverFetcher";
import type * as Schemas from "./serverSchemas";

export type AppControllerStatusError = Fetcher.ErrorWrapper<undefined>;

export type AppControllerStatusVariables = ServerContext["fetcherOptions"];

export const fetchAppControllerStatus = (
  variables: AppControllerStatusVariables,
  signal?: AbortSignal
) =>
  serverFetch<undefined, AppControllerStatusError, undefined, {}, {}, {}>({
    url: "/",
    method: "get",
    ...variables,
    signal,
  });

export const useAppControllerStatus = <TData = undefined>(
  variables: AppControllerStatusVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, AppControllerStatusError, TData>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useServerContext(options);
  return reactQuery.useQuery<undefined, AppControllerStatusError, TData>(
    queryKeyFn({ path: "/", operationId: "appControllerStatus", variables }),
    ({ signal }) =>
      fetchAppControllerStatus({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type ProjectsControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type ProjectsControllerCreateVariables = {
  body: Schemas.CreateProjectDto;
} & ServerContext["fetcherOptions"];

/**
 * Create a new project with 2 questions and their answers
 */
export const fetchProjectsControllerCreate = (
  variables: ProjectsControllerCreateVariables,
  signal?: AbortSignal
) =>
  serverFetch<
    Schemas.ProjectDetailResponse,
    ProjectsControllerCreateError,
    Schemas.CreateProjectDto,
    {},
    {},
    {}
  >({ url: "/projects", method: "post", ...variables, signal });

/**
 * Create a new project with 2 questions and their answers
 */
export const useProjectsControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ProjectDetailResponse,
      ProjectsControllerCreateError,
      ProjectsControllerCreateVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useServerContext();
  return reactQuery.useMutation<
    Schemas.ProjectDetailResponse,
    ProjectsControllerCreateError,
    ProjectsControllerCreateVariables
  >(
    (variables: ProjectsControllerCreateVariables) =>
      fetchProjectsControllerCreate({ ...fetcherOptions, ...variables }),
    options
  );
};

export type ProjectsControllerFindOnePathParams = {
  id: string;
};

export type ProjectsControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type ProjectsControllerFindOneVariables = {
  pathParams: ProjectsControllerFindOnePathParams;
} & ServerContext["fetcherOptions"];

/**
 * Get one project by id
 */
export const fetchProjectsControllerFindOne = (
  variables: ProjectsControllerFindOneVariables,
  signal?: AbortSignal
) =>
  serverFetch<
    Schemas.ProjectDetailResponse,
    ProjectsControllerFindOneError,
    undefined,
    {},
    {},
    ProjectsControllerFindOnePathParams
  >({ url: "/projects/{id}", method: "get", ...variables, signal });

/**
 * Get one project by id
 */
export const useProjectsControllerFindOne = <
  TData = Schemas.ProjectDetailResponse
>(
  variables: ProjectsControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ProjectDetailResponse,
      ProjectsControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useServerContext(options);
  return reactQuery.useQuery<
    Schemas.ProjectDetailResponse,
    ProjectsControllerFindOneError,
    TData
  >(
    queryKeyFn({
      path: "/projects/{id}",
      operationId: "projectsControllerFindOne",
      variables,
    }),
    ({ signal }) =>
      fetchProjectsControllerFindOne(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type AnswerControllerFindUnansweredQueryParams = {
  answeredIds: string[];
};

export type AnswerControllerFindUnansweredError =
  Fetcher.ErrorWrapper<undefined>;

export type AnswerControllerFindUnansweredVariables = {
  queryParams: AnswerControllerFindUnansweredQueryParams;
} & ServerContext["fetcherOptions"];

/**
 * Get unanswered questions
 */
export const fetchAnswerControllerFindUnanswered = (
  variables: AnswerControllerFindUnansweredVariables,
  signal?: AbortSignal
) =>
  serverFetch<
    Schemas.ProjectResponse,
    AnswerControllerFindUnansweredError,
    undefined,
    {},
    AnswerControllerFindUnansweredQueryParams,
    {}
  >({ url: "/answer", method: "get", ...variables, signal });

/**
 * Get unanswered questions
 */
export const useAnswerControllerFindUnanswered = <
  TData = Schemas.ProjectResponse
>(
  variables: AnswerControllerFindUnansweredVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ProjectResponse,
      AnswerControllerFindUnansweredError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useServerContext(options);
  return reactQuery.useQuery<
    Schemas.ProjectResponse,
    AnswerControllerFindUnansweredError,
    TData
  >(
    queryKeyFn({
      path: "/answer",
      operationId: "answerControllerFindUnanswered",
      variables,
    }),
    ({ signal }) =>
      fetchAnswerControllerFindUnanswered(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type AnswerControllerSubmitAnswerToProjectQueryParams = {
  projectId: string;
  firstAnswerId: string;
  secondAnswerId: string;
};

export type AnswerControllerSubmitAnswerToProjectError =
  Fetcher.ErrorWrapper<undefined>;

export type AnswerControllerSubmitAnswerToProjectVariables = {
  queryParams: AnswerControllerSubmitAnswerToProjectQueryParams;
} & ServerContext["fetcherOptions"];

/**
 * Enter a response for a project
 */
export const fetchAnswerControllerSubmitAnswerToProject = (
  variables: AnswerControllerSubmitAnswerToProjectVariables,
  signal?: AbortSignal
) =>
  serverFetch<
    Schemas.AnswerProjectResponse,
    AnswerControllerSubmitAnswerToProjectError,
    undefined,
    {},
    AnswerControllerSubmitAnswerToProjectQueryParams,
    {}
  >({ url: "/answer", method: "post", ...variables, signal });

/**
 * Enter a response for a project
 */
export const useAnswerControllerSubmitAnswerToProject = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AnswerProjectResponse,
      AnswerControllerSubmitAnswerToProjectError,
      AnswerControllerSubmitAnswerToProjectVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useServerContext();
  return reactQuery.useMutation<
    Schemas.AnswerProjectResponse,
    AnswerControllerSubmitAnswerToProjectError,
    AnswerControllerSubmitAnswerToProjectVariables
  >(
    (variables: AnswerControllerSubmitAnswerToProjectVariables) =>
      fetchAnswerControllerSubmitAnswerToProject({
        ...fetcherOptions,
        ...variables,
      }),
    options
  );
};

export type QueryOperation =
  | {
      path: "/";
      operationId: "appControllerStatus";
      variables: AppControllerStatusVariables;
    }
  | {
      path: "/projects/{id}";
      operationId: "projectsControllerFindOne";
      variables: ProjectsControllerFindOneVariables;
    }
  | {
      path: "/answer";
      operationId: "answerControllerFindUnanswered";
      variables: AnswerControllerFindUnansweredVariables;
    };
